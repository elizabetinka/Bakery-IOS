# Лабораторная №2

## Задача

Спроектировать приложение, использовав выбранную архитектуру (аргументированно), описав все интерфейсы для взаимодействия + структуры для передачи данных и workflow.

Приложение должно содержать:
- Экран авторизации
- Экран со списком фичей/услуг/возможностей/итд
- Экран с реализацией фичи/услуги/возможности/итд

### Ключевые моменты

- Реализовывать приложение не нужно, только спроектировать интерфейсы
- Для UI лучше подойдет UIKit (SwiftUI выходит за рамки и не требуется)
- Приложение должно поддерживать выбранную архитектуру на всех слоях

Архитектуры на выбор:
- MVC
- MVP
- MVVM
- VIPER
- YARCH (Clean Swift)
- Любая другая, если знаете хорошую и хотите применить

Архитектура должна быть хорошо тестируема (интерфейс должен подразумевать наличие моков).


Тематика приложения может быть:
- Банковское приложение
- Приложения доставки продуктов
- Финансовый советник
- Имеджборд 
- Сервис для покупки чего-либо
- Любая другая тема (необходимо согласовать)

### Требования

Приложение должно быть спроектировано без реализации, но, все структуры для передачи данных между интерфейсами, нужно реализовать.

Если в приложении требуется хранилище данных, можно обойтись обычным фасадом, чтобы не вдаваться в подробности реализации.

Желательно приложить комментарии для описания сущности.

## Дополнительно

- Количество экранов и их вариантов может быть больше 5 с частными релизациями
- Обработать различные состояния жизненного цикла и сделать с этим что-то (например, вывести информацию на экран)


# Лабораторная №3

## Задача

Реализовать экран с авторизацией, добавив на него текстовые поля для логина и пароля, а так же кнопку для авторизации. Если логин и пароль верные - перейти на экран со списком фичей (можно пока оставить заглушку и просто принтить что-то в консоль)

### Ключевые моменты

- UI должен быть реализован с помощью UIKit
- Экран должен работать, согласно выбранной архитектуре приложения. 
- Обратить внимание на маленькие экраны и клавиатуру, которая может перекрыть само текстовое поле

### Требования

 - Все вьюшки на экране должны поддерживать динамическую верстку и быть закрепленными констрейнтами
 - Код должен быть чистым и безопасным (без внезапных крашей, с обработкой ошибок)

## Дополнительно

- Добавить визуальную обработку ошибок
- Добавить валидацию email и/или пароля в реальном времени с отображением невалидности


# Лабораторная №4

## Задача

Реализовать загрузку из сети экрана со списком продуктов (экран после авторизации из предыдущей лабораторной). Реализовывать UI, пока, не нужно, нужно только реализовать часть с логикой, загрузкой информации и формирования вьюмодели для вью слоя.

### Ключевые моменты

- Загрузка не должна блокировать UI
- Полученные данные нужно парсить, например, с помощью `Codable`
- Данные с сервера нужно передать во вью слой, сформировав из них модели, готовые к отображению (минимум лишней информации, никакой логики во вью слое)
- Загружать данные можно с любого публичного API на ваш выбор, подходящий по смыслу вашему приложению, например:
    - https://petstore.swagger.io/
    - https://docs.spacexdata.com/
    - https://restninja.io/
- Есть еще подборка публичных API:
    - https://pxstudio.pw/blog/15-besplatnyh-api-dlya-napisaniya-testovyh-prilozhenij
- И есть еще echo сервер
    - https://beeceptor.com/resources/http-echo/
- Так же, можно через наш собственный сервер сделать себе запросов, подробности по нему скину отдельно

### Требования

 - Данные должны загружаться из API в формате массива данных (для отображения списка)
 - Загрузка должна происходить асинхронно и не блокировать текущее отображение
 - Загружать можно с помощью нативной URLSession, с помощью Alamofire или других фреймворков (с аргументацией)
 - Для парсинга моделек предпочтительнее использовать Codable, но можно и прямой парсинг из Data. Запрещается использование динамических сторонних фреймворков (типо SwiftyJSON и так далее)
 - При загрузке на экране отобразить индикатор загрузки или любое другое отображение информации о наличии процесса

## Дополнительно

- Реализовать авторизацию с помощью публичного API вместо локальной проверки
- Сделать пагинацию и постраничную загрузку списка (+2 балла)
- Добавить локальное кэаширование, чтобы не грузить данные повторно (если кэширование в файл, то должна быть политика инвалидации кэша)

# Лабораторная №5

## Задача

Добавить переход между экранами (авторизация, список и тд), а так же добавить UI для экрана со списком (который загружается в рамках лабораторной №4, например). Список должен скроллиться и обрабатывать события пользователя (например, нажатия).

### Ключевые моменты

- Список должен использовать технологию Reusable (например, UITableView или UICollectionView)
- Для отображения ячеек нужно разработать свою ячейку/ячейки и конфигурировать их в DataSource
- Обработка нажатий должна быть реализована с помощью делегата
- Роутинг между экранами должен быть реализован через отдельный роутер

### Требования

 - Отображение списка должно быть неблокирующим (не должно быть лагов при скроллинге)
 - Для работы TableView/CollectionView нужно пользоваться отдельной сущностью (например, TableManager), которая реализовывает все необходимые протоколы и общается с вью слоем (например, ViewController) с помощью протоколов (TableManager должен быть закрыт протоколом, ViewController будет его делегатом (!!!не путать с UITableViewDelegate!!!))
     - `UIViewController` holds `protocol TableManager`
     - `TableManager` holds `protocol TableManagerDelegate`
     - `UIViewController` implements `protocol TableManagerDelegate`
 - Роутер должен быть закрыт протоколом и обезличен
 - Данные с API не должны передаваться во вью слой, ячейки должны быть сконфигурированы вполне конкретными ViewModel, описывающими все необходимые поля

## Дополнительно

- Добавить `UIRefreshControl` и обновлять контент по Pull-to-Refresh
- Сделать `GenericCell` с дженериком для типа вью и вьюмодели, чтобы можно было любую View подписать под протокол (необходимый для включения в ячейку) и засунуть в TableView/CollectionView
- Добавить в ячейки картинки, загружаемые с интернета (с отображением процесса загрузки, например, ромашкой)


# Лабораторная №6

## Задача

Добавить реализацию Дизайн Системы в свое приложение.

### Ключевые моменты

- В качестве дизайн системы можно использовать [Sample от Figma](https://www.figma.com/community/file/1380235722331273046)
- Так как Sample слишком большой, реализовывать нужно только необходимое
- Реализовать нужно минимум 3-4 вьюшки и часть их инвариантов
- Минимально - Label, Button, TextInput должны быть
- Дизайн система должна лежать в отдельной директории и быть доступна для использования, но закрыта для изменений
- Для расположения вьюшек должны быть фиксированные токены отступов
- Желательно добавить StackView для более удобного размещения вьюшек

### Требования

 - Нужно выбрать вьюшки из Sample для реализации, создать для каждой из них сущность в вашей ДС в приложении (субдиректорию можно назвать `Components`, `DesignSystem` и тд)
 - Для каждой вьюшки необходимо реализовать несколько инвариантов отрисовки (не обязательно все из Figma DS, но хотя бы 2-3)
 - Вьюшка должна конфигурироваться с помощью некой ViewModel, описывающей все возможности конфигурации (включая стили)
 - Вьюшки не должны конфигурировать извне никак иначе, кроме ViewModel
 - Для обработки нажатий и действий пользователя можно пользоваться любым из возможных вариантов (target-action, completion, binding и тд)

## Дополнительно

- Добавить 5+ вьюшек с 3 и более инвариантов
- Перевести текущее приложение (авторизация, список и тд) на  дизайн систему (2 балла)

В качестве дизайн системы можно использовать [Sample от Figma](https://www.figma.com/community/file/1380235722331273046)
- Так как Sample слишком большой, реализовывать нужно только необходимое
- Реализовать нужно минимум 3-4 вьюшки и часть их инвариантов
- Минимально - Label, Button, TextInput должны быть
- Дизайн система должна лежать в отдельной директории и быть доступна для использования, но закрыта для изменений
- Для расположения вьюшек должны быть фиксированные токены отступов
 Нужно выбрать вьюшки из Sample для реализации, создать для каждой из них сущность в вашей ДС в приложении (субдиректорию можно назвать `Components`, `DesignSystem` и тд)
 - Для каждой вьюшки необходимо реализовать несколько инвариантов отрисовки (не обязательно все из Figma DS, но хотя бы 2-3)
 
 
 
# Лабораторная №7

## Задача

Добавить реализацию Backend Driven UI для дизайн системы и обернуть ее в мапперы. Мапперы должны уметь возвращать вьюшки и их сабвьюшки с помощью модели, получаемой из JSON.

### Ключевые моменты

- BDUI маппер должен принимать в себя некоторую модель, которая может содержать вложенные модели и так до бескончености, описывающие вьюшки, вложенные сабвьюишки и их верстку
- Модель, передаваемая в маппер должна поддерживать декодинг из JSON
- Пример простого JSON:
```json
{
    "type": "contentView",
    "content": {
        "style": "plain",
        "backgroundColor: "white"        
    },
    "subviews": [
        {
            "type": "stackView",
            "content": {
                "spacing": "s" // Токен спейсинга из дизайн системы, например 16
            },
            "subviews": [
                {
                    "type": "label",
                    "content": {
                        "text": "Привет, ИТМО!"
                    }
                },
                {
                    "type": "button",
                    "content": {
                        "text": "Нажми меня",
                        "action": {
                            "type": "print",
                            "context": {
                                "Кнопка была нажата"
                            }
                        }
                    }
                }
            ]
        }
    ]
    
}
```
- JSON не обязательно должен быть таким, как в примере, это просто показывает то, какой он может быть
- Ваш конфигуратор должен отражать возможности дизайн системы
- Для простоты верстки можно пользоваться StackView (их можно вкладывать друг в друга), чтобы не делать BDUI верстку
- По схеме подобной модели напрашивается использование Generic'ов и Enum'ов

### Требования

 - Маппер должен принимать абстрактную модель и возвращать UIView
 - Все вьюшки и сабвьюшки должны быть верно сконфигурированы, согласно дизайн системе (в JSON должны содержаться данные для ViewModel)
 - Маппер должен возвращать вьюшку с учетом верстки, чтобы ее можно было сразу разместить на экране
 - Вьюшки не должны дополнительно обогощаться и обрабатываться после работы маппера
 - Маппер должен работать всегда по одному принципу, без корнер кейсов для конкретных фичей (быть абстрактным)
 - Маппер должен быть закрыт за протоколом

## Дополнительно

- Реализовать различные экшены для реакций пользователя (роутинг, релоад экрана и тд)
- Добавить в маппер расширенную дизайн систему (больше 5 вьюшек + контейнеры + констренты и тд) - 2 балла


# Лабораторная №8

## Задача

Добавить экран на Backend Driven UI, используя маппер из Лабораторной работы №7

### Ключевые моменты

- Добавить универсальный экран, который будет принимать некий конфиг (включая endpoint) и отображаться на экране
- По endpoint этот экран должен загружать данные для отображения с сервера (можно использовать https://alfa-itmo.ru/server/v1/storage/:key)
- С помощью маппера, полученная модель должна быть распаршена в UIView и отображена с помощью универсального экрана
- Экран должен быть открыт из любого предыдущего

### Требования

 - Экран должен быть абстрактным и не зависеть от конкретной фичовой логики
 - Экран должен быть сконфигурирован из любого из текущих экранов (например из списка)
 - Конфигурация должна предполагать некие абстрактные параметры (эндпоинт, ключ и тд), с помощью которых будет загружена модель для маппера BDUI
 - Экран должен правильно отрисовываться, согласно логики с сервера
 - В зависимости от пришедшего конфига, загрузка экрана должна отличаться

## Дополнительно

- Отобразить сложный экран со скроллом и большим количеством контента
- Добавить несколько вариаций BDUI экранов (например, для разных фичей) + 2 балла

