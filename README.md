# Лабораторная №2

## Задача

Спроектировать приложение, использовав выбранную архитектуру (аргументированно), описав все интерфейсы для взаимодействия + структуры для передачи данных и workflow.

Приложение должно содержать:
- Экран авторизации
- Экран со списком фичей/услуг/возможностей/итд
- Экран с реализацией фичи/услуги/возможности/итд

### Ключевые моменты

- Реализовывать приложение не нужно, только спроектировать интерфейсы
- Для UI лучше подойдет UIKit (SwiftUI выходит за рамки и не требуется)
- Приложение должно поддерживать выбранную архитектуру на всех слоях

Архитектуры на выбор:
- MVC
- MVP
- MVVM
- VIPER
- YARCH (Clean Swift)
- Любая другая, если знаете хорошую и хотите применить

Архитектура должна быть хорошо тестируема (интерфейс должен подразумевать наличие моков).


Тематика приложения может быть:
- Банковское приложение
- Приложения доставки продуктов
- Финансовый советник
- Имеджборд 
- Сервис для покупки чего-либо
- Любая другая тема (необходимо согласовать)

### Требования

Приложение должно быть спроектировано без реализации, но, все структуры для передачи данных между интерфейсами, нужно реализовать.

Если в приложении требуется хранилище данных, можно обойтись обычным фасадом, чтобы не вдаваться в подробности реализации.

Желательно приложить комментарии для описания сущности.

## Дополнительно

- Количество экранов и их вариантов может быть больше 5 с частными релизациями
- Обработать различные состояния жизненного цикла и сделать с этим что-то (например, вывести информацию на экран)


# Лабораторная №3

## Задача

Реализовать экран с авторизацией, добавив на него текстовые поля для логина и пароля, а так же кнопку для авторизации. Если логин и пароль верные - перейти на экран со списком фичей (можно пока оставить заглушку и просто принтить что-то в консоль)

### Ключевые моменты

- UI должен быть реализован с помощью UIKit
- Экран должен работать, согласно выбранной архитектуре приложения. 
- Обратить внимание на маленькие экраны и клавиатуру, которая может перекрыть само текстовое поле

### Требования

 - Все вьюшки на экране должны поддерживать динамическую верстку и быть закрепленными констрейнтами
 - Код должен быть чистым и безопасным (без внезапных крашей, с обработкой ошибок)

## Дополнительно

- Добавить визуальную обработку ошибок
- Добавить валидацию email и/или пароля в реальном времени с отображением невалидности


# Лабораторная №4

## Задача

Реализовать загрузку из сети экрана со списком продуктов (экран после авторизации из предыдущей лабораторной). Реализовывать UI, пока, не нужно, нужно только реализовать часть с логикой, загрузкой информации и формирования вьюмодели для вью слоя.

### Ключевые моменты

- Загрузка не должна блокировать UI
- Полученные данные нужно парсить, например, с помощью `Codable`
- Данные с сервера нужно передать во вью слой, сформировав из них модели, готовые к отображению (минимум лишней информации, никакой логики во вью слое)
- Загружать данные можно с любого публичного API на ваш выбор, подходящий по смыслу вашему приложению, например:
    - https://petstore.swagger.io/
    - https://docs.spacexdata.com/
    - https://restninja.io/
- Есть еще подборка публичных API:
    - https://pxstudio.pw/blog/15-besplatnyh-api-dlya-napisaniya-testovyh-prilozhenij
- И есть еще echo сервер
    - https://beeceptor.com/resources/http-echo/
- Так же, можно через наш собственный сервер сделать себе запросов, подробности по нему скину отдельно

### Требования

 - Данные должны загружаться из API в формате массива данных (для отображения списка)
 - Загрузка должна происходить асинхронно и не блокировать текущее отображение
 - Загружать можно с помощью нативной URLSession, с помощью Alamofire или других фреймворков (с аргументацией)
 - Для парсинга моделек предпочтительнее использовать Codable, но можно и прямой парсинг из Data. Запрещается использование динамических сторонних фреймворков (типо SwiftyJSON и так далее)
 - При загрузке на экране отобразить индикатор загрузки или любое другое отображение информации о наличии процесса

## Дополнительно

- Реализовать авторизацию с помощью публичного API вместо локальной проверки
- Сделать пагинацию и постраничную загрузку списка (+2 балла)
- Добавить локальное кэаширование, чтобы не грузить данные повторно (если кэширование в файл, то должна быть политика инвалидации кэша)
